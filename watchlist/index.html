<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Our Watchlist</title>
    <style>
        :root {
            /* Light Mode Colors */
            --color-bg: #ffccbc;
            --color-text: #1a1a1a;
            --color-text-secondary: #4a4a4a;
            --color-button: #07450b;
            --color-accent: #ffccbc;
            --color-surface: #ffffff;
            --color-surface-alt: #f5f5f5;
            --color-border: #d0d0d0;
            --color-error: #c54034;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                /* Dark Mode Colors */
                --color-bg: #000000;
                --color-text: #f5f5f5;
                --color-text-secondary: #d0d0d0;
                --color-button: #ffccbc;
                --color-accent: #ffccbc;
                --color-surface: #0a1f0a;
                --color-surface-alt: #252e25;
                --color-border: #2d5a2d;
                --color-error: #ff6b6b;
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: var(--color-bg);
            color: var(--color-text);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        /* Login Page */
        .login-container {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }

        .login-box {
            background: var(--color-surface);
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 400px;
            width: 100%;
        }

        .login-box h1 {
            color: var(--color-text);
            margin-bottom: 30px;
            font-size: 2em;
        }

        .login-box input {
            width: 100%;
            padding: 15px;
            border: 2px solid var(--color-border);
            border-radius: 10px;
            font-size: 16px;
            margin-bottom: 20px;
            transition: border-color 0.3s;
        }

        .login-box input:focus {
            outline: none;
            border-color: var(--color-text);
        }

        .btn {
            background: var(--color-button);
            color: #ffffff;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s, opacity 0.2s;
            width: 100%;
        }

        .btn:hover {
            transform: translateY(-2px);
            opacity: 0.9;
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: var(--color-accent);
            color: var(--color-text);
            margin-top: 10px;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 14px;
            width: auto;
        }

        .error {
            color: var(--color-error);
            margin-top: 10px;
            font-size: 14px;
        }

        /* Main App */
        .app-container {
            display: none;
        }

        .app-container.active {
            display: block;
        }

        .header {
            background: var(--color-surface);
            padding: 20px 30px;
            border-radius: 20px;
            margin-bottom: 30px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .header h1 {
            color: var(--color-text);
            font-size: 2em;
        }

        .search-container {
            background: var(--color-surface);
            padding: 30px;
            border-radius: 20px;
            margin-bottom: 30px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
        }

        .search-box {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .search-box input {
            flex: 1;
            padding: 15px;
            border: 2px solid var(--color-border);
            border-radius: 10px;
            font-size: 16px;
            min-width: 200px;
        }

        .search-box input:focus {
            outline: none;
            border-color: var(--color-text);
        }

        .search-box select {
            padding: 15px;
            border: 2px solid var(--color-border);
            border-radius: 10px;
            font-size: 16px;
            background: var(--color-surface);
            cursor: pointer;
        }

        .search-results {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .search-result-item {
            cursor: pointer;
            border-radius: 10px;
            overflow: hidden;
            transition: transform 0.2s;
            background: var(--color-surface-alt);
            border: 2px solid transparent;
        }

        .search-result-item:hover {
            transform: scale(1.05);
            border-color: var(--color-accent);
        }

        .search-result-item img {
            width: 100%;
            height: 225px;
            object-fit: cover;
        }

        .search-result-item .title {
            padding: 10px;
            font-size: 14px;
            font-weight: 600;
            text-align: center;
        }

        .manual-add {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid #e0e0e0;
        }

        .manual-add h3 {
            margin-bottom: 15px;
            color: var(--color-text);
        }

        .manual-add input, .manual-add textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--color-border);
            border-radius: 10px;
            font-size: 16px;
            margin-bottom: 10px;
            font-family: inherit;
        }

        .manual-add input:focus, .manual-add textarea:focus {
            outline: none;
            border-color: var(--color-text);
        }

        .manual-add textarea {
            min-height: 80px;
            resize: vertical;
        }

        .watchlist-container {
            background: var(--color-surface);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
        }

        .filter-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: flex-start;
        }

        .filter-group {
            flex: 1;
            min-width: 200px;
        }

        .filter-label {
            font-weight: 600;
            color: var(--color-text);
            margin-bottom: 8px;
            font-size: 14px;
        }

        .filter-select {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid var(--color-border);
            border-radius: 10px;
            font-size: 16px;
            background: var(--color-surface);
            cursor: pointer;
            font-weight: 600;
            transition: border-color 0.3s;
            color: var(--color-text);
        }

        .filter-select:hover {
            border-color: var(--color-accent);
        }

        .filter-select:focus {
            outline: none;
            border-color: var(--color-text);
        }

        .genre-select-container {
            position: relative;
        }

        .genre-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--color-surface);
            border: 2px solid var(--color-border);
            border-radius: 10px;
            margin-top: 5px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 10px 30px rgba(255, 179, 217, 0.3);
            display: none;
        }

        .genre-dropdown.active {
            display: block;
        }

        .genre-option {
            padding: 10px 15px;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .genre-option:hover {
            background: var(--color-surface-alt);
        }

        .genre-option input[type="checkbox"] {
            cursor: pointer;
        }

        .selected-genres {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 8px;
        }

        .genre-tag {
            background: var(--color-button);
            color: #ffffff;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .genre-tag-remove {
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
        }

        .genre-tag-remove:hover {
            opacity: 0.7;
        }

        .watchlist-items {
            display: grid;
            gap: 20px;
        }

        .watchlist-item {
            background: var(--color-surface-alt);
            border-radius: 15px;
            padding: 20px;
            display: grid;
            grid-template-columns: auto 1fr auto;
            gap: 20px;
            align-items: start;
        }

        .watchlist-item.watched {
            opacity: 0.7;
        }

        .item-poster {
            width: 80px;
            height: 120px;
            object-fit: cover;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transition: width 0.6s ease, height 0.6s ease, box-shadow 0.6s ease;
        }

        .watchlist-item.collapsed .item-poster {
            width: 50px;
            height: 75px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .item-details {
            flex: 1;
            min-width: 0;
            overflow-wrap: break-word;
            word-wrap: break-word;
        }

        .item-title {
            font-size: 1.3em;
            font-weight: 700;
            color: var(--color-text);
            margin-bottom: 5px;
            overflow-wrap: break-word;
            word-wrap: break-word;
        }

        .item-meta {
            color: var(--color-text-secondary);
            font-size: 0.9em;
            margin-bottom: 10px;
            overflow-wrap: break-word;
            word-wrap: break-word;
        }

        .item-genres {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }

        .genre-badge {
            background: var(--color-accent);
            color: #052905;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: 600;
        }

        .item-overview {
            color: var(--color-text-secondary);
            line-height: 1.5;
            margin-bottom: 10px;
            overflow-wrap: break-word;
            word-wrap: break-word;
        }

        .item-links {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .item-links a {
            color: var(--color-text);
            text-decoration: underline;
            font-weight: 600;
            font-size: 0.9em;
            overflow-wrap: break-word;
            word-wrap: break-word;
        }

        .item-links a:hover {
            text-decoration: underline;
        }

        .item-notes {
            margin-top: 10px;
            padding: 10px;
            background: var(--color-surface);
            border-radius: 8px;
            color: var(--color-text-secondary);
            font-size: 0.9em;
            font-style: italic;
        }

        .notes-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px solid var(--color-border);
        }

        .notes-form textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid var(--color-border);
            border-radius: 8px;
            margin-top: 8px;
            font-family: inherit;
            font-size: 16px;
            min-height: 60px;
        }

        .notes-form textarea:focus {
            outline: none;
            border-color: var(--color-text);
        }

        .tags-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px solid var(--color-border);
        }

        .item-tags {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .tag-badge {
            background: var(--color-button);
            color: #ffffff;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .tag-remove {
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
        }

        .tag-remove:hover {
            opacity: 0.7;
        }

        .review-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px solid var(--color-border);
        }

        .review-text {
            background: var(--color-surface);
            padding: 12px;
            border-radius: 8px;
            margin-top: 8px;
            font-style: italic;
            color: var(--color-text-secondary);
        }

        .review-form textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid var(--color-border);
            border-radius: 8px;
            margin-top: 8px;
            font-family: inherit;
            font-size: 16px;
            min-height: 60px;
        }

        .review-form textarea:focus {
            outline: none;
            border-color: var(--color-text);
        }

        .ratings-section {
            margin-top: 15px;
            padding: 15px;
            background: var(--color-surface-alt);
            border-radius: 10px;
        }

        .rating-input-group {
            margin-bottom: 15px;
        }

        .rating-label {
            font-weight: 600;
            color: var(--color-text);
            margin-bottom: 8px;
        }

        .rating-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .rating-row input {
            width: 60px;
            padding: 6px 10px;
            border: 2px solid var(--color-border);
            border-radius: 8px;
            font-size: 16px;
            text-align: center;
        }

        .rating-row input:focus {
            outline: none;
            border-color: var(--color-text);
        }

        .ratings-section .btn-small {
            margin-top: 10px;
        }

        .ratings-section .btn-small:hover {
            transform: none;
        }

        .stars-display {
            color: var(--color-accent);
            font-size: 18px;
            letter-spacing: 2px;
        }

        .rating-number {
            color: var(--color-text-secondary);
            font-size: 14px;
            margin-left: 8px;
        }

        .item-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .btn-action {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .btn-watched {
            background: var(--color-button);
            color: #ffffff;
        }

        .btn-watched:hover {
            opacity: 0.8;
        }

        .btn-review {
            background: var(--color-accent);
            color: var(--color-text);
        }

        .btn-review:hover {
            opacity: 0.8;
        }

        .btn-delete {
            background: var(--color-error);
            color: #ffffff;
        }

        .btn-delete:hover {
            opacity: 0.8;
        }

        .btn-collapse {
            background: var(--color-accent);
            color: #ffffff;
        }

        .btn-collapse:hover {
            opacity: 0.8;
        }

        .item-details > * {
            transition: opacity 0.6s ease, max-height 0.6s ease;
            max-height: 1000px;
            opacity: 1;
            overflow: hidden;
        }

        .watchlist-item.collapsed .item-details > *:not(.item-title):not(.item-meta):not(.item-genres):not(.item-notes) {
            max-height: 0;
            opacity: 0;
            margin: 0;
            padding: 0;
        }

        .item-actions {
            transition: opacity 0.6s ease, max-height 0.6s ease;
            max-height: 200px;
            opacity: 1;
        }

        .watchlist-item.collapsed .item-actions {
            max-height: 0;
            opacity: 0;
            overflow: hidden;
        }

        .collapse-all-container {
            display: flex;
            justify-content: flex-end;
            margin-bottom: 15px;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--color-text);
        }

        .empty-state h3 {
            font-size: 1.5em;
            margin-bottom: 10px;
            color: var(--color-text);
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: var(--color-text);
            font-weight: 600;
        }

        @media (prefers-color-scheme: dark) {
            .btn, .btn-watched, .btn-review, .btn-delete, .btn-action, .btn-collapse {
                color: #1a1a1a;
            }
        }

        /* Wizard Modal */
        .wizard-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .wizard-overlay.active {
            display: flex;
        }

        .wizard-modal {
            background: var(--color-surface);
            border-radius: 20px;
            padding: 30px;
            max-width: 600px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .wizard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
        }

        .wizard-header h2 {
            color: var(--color-text);
            font-size: 1.8em;
        }

        .wizard-close {
            background: none;
            border: none;
            font-size: 28px;
            cursor: pointer;
            color: var(--color-text);
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .wizard-close:hover {
            opacity: 0.7;
        }

        .wizard-step {
            display: none;
        }

        .wizard-step.active {
            display: block;
        }

        .wizard-step h3 {
            color: var(--color-text);
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .wizard-options {
            display: grid;
            gap: 10px;
            margin-bottom: 20px;
        }

        .wizard-option {
            padding: 15px;
            border: 2px solid var(--color-border);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            background: var(--color-surface-alt);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .wizard-option:hover {
            border-color: var(--color-accent);
            background: var(--color-surface);
        }

        .wizard-option.selected {
            border-color: var(--color-button);
            background: var(--color-surface);
        }

        .wizard-option input[type="checkbox"] {
            cursor: pointer;
            width: 20px;
            height: 20px;
        }

        .wizard-option label {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-text);
            flex: 1;
        }

        .wizard-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        .wizard-results {
            display: grid;
            gap: 20px;
        }

        .wizard-result-item {
            background: var(--color-surface-alt);
            border-radius: 15px;
            padding: 20px;
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 20px;
            align-items: start;
        }

        .wizard-result-poster {
            width: 80px;
            height: 120px;
            object-fit: cover;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .wizard-result-details {
            flex: 1;
        }

        .wizard-result-title {
            font-size: 1.3em;
            font-weight: 700;
            color: var(--color-text);
            margin-bottom: 5px;
        }

        .wizard-result-meta {
            color: var(--color-text-secondary);
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        .wizard-result-overview {
            color: var(--color-text-secondary);
            line-height: 1.5;
            margin-top: 10px;
        }

        .wizard-empty {
            text-align: center;
            padding: 40px 20px;
            color: var(--color-text-secondary);
        }

        .wizard-empty h3 {
            font-size: 1.3em;
            margin-bottom: 10px;
            color: var(--color-text);
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .watchlist-item {
                grid-template-columns: 1fr;
                padding: 15px;
            }

            .watchlist-container {
                padding: 15px;
            }

            .search-container {
                padding: 15px;
            }

            .header {
                flex-direction: column;
                text-align: center;
                padding: 15px 20px;
            }

            .item-actions {
                flex-direction: row;
                flex-wrap: wrap;
            }

            .search-box {
                flex-direction: column;
            }

            .search-results {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            }

            .wizard-modal {
                padding: 20px;
            }

            .wizard-result-item {
                grid-template-columns: 1fr;
            }

            .wizard-buttons {
                flex-direction: column;
            }

            .wizard-buttons .btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <!-- Login Page -->
    <div id="loginPage" class="login-container">
        <div class="login-box">
            <h1>ðŸŽ¬ Our Watchlist</h1>
            <input type="password" id="passwordInput" placeholder="Enter password" autofocus>
            <button class="btn" onclick="login()">Login</button>
            <div id="loginError" class="error"></div>
        </div>
    </div>

    <!-- Main App -->
    <div id="appPage" class="app-container">
        <div class="container">
            <div class="header">
                <h1>ðŸŽ¬ Our Watchlist</h1>
                <button class="btn btn-small" onclick="logout()">Logout</button>
            </div>

            <!-- Search and Add Section -->
            <div class="search-container">
                <h2 style="margin-bottom: 20px; color: var(--color-text);">Add New Item</h2>

                <div class="search-box">
                    <div class="genre-select-container" style="min-width: 150px;">
                        <button id="searchMediaTypeButton" class="filter-select" onclick="toggleSearchMediaTypeDropdown(event)" style="text-align: left;">
                            Movie
                        </button>
                        <div id="searchMediaTypeDropdown" class="genre-dropdown"></div>
                    </div>
                    <input type="text" id="searchInput" placeholder="Search for media...">
                    <button class="btn btn-small" onclick="searchMedia()">Search</button>
                </div>

                <div id="searchResults" class="search-results"></div>

                <!-- Manual Add Form -->
                <div id="manualAddForm" class="manual-add" style="display: none;">
                    <h3>Add Manually</h3>
                    <input type="text" id="manualTitle" placeholder="Title">
                    <input type="text" id="manualType" placeholder="Type (e.g., Album, Documentary, Article)">
                    <textarea id="manualNotes" placeholder="Notes or description (optional)"></textarea>
                    <button class="btn" onclick="addManualItem()">Add to Watchlist</button>
                </div>
            </div>

            <!-- Watchlist Section -->
            <div class="watchlist-container">
                <h2 style="margin-bottom: 20px; color: var(--color-text);">Watchlist</h2>

                <div class="collapse-all-container">
                    <button class="btn btn-small" onclick="openHelpMeDecideWizard()" style="margin-right: 10px;">
                        Help Me Decide
                    </button>
                    <button class="btn btn-small" onclick="toggleAllCollapsed()">
                        <span id="collapseAllText">Collapse All</span>
                    </button>
                </div>

                <div class="filter-controls">
                    <div class="filter-group">
                        <div class="filter-label">Filter by:</div>
                        <div class="genre-select-container">
                            <button id="mediaTypeFilterButton" class="filter-select" onclick="toggleMediaTypeDropdown()" style="text-align: left;">
                                All
                            </button>
                            <div id="mediaTypeDropdown" class="genre-dropdown"></div>
                        </div>
                    </div>

                    <div class="filter-group">
                        <div class="filter-label">Genre:</div>
                        <div class="genre-select-container">
                            <button id="genreFilterButton" class="filter-select" onclick="toggleGenreDropdown(event)" style="text-align: left;">
                                Select genres...
                            </button>
                            <div id="genreDropdown" class="genre-dropdown"></div>
                            <div id="selectedGenresDisplay" class="selected-genres"></div>
                        </div>
                    </div>

                    <div class="filter-group">
                        <div class="filter-label">Tags:</div>
                        <div class="genre-select-container">
                            <button id="tagFilterButton" class="filter-select" onclick="toggleTagDropdown(event)" style="text-align: left;">
                                Select tags...
                            </button>
                            <div id="tagDropdown" class="genre-dropdown"></div>
                            <div id="selectedTagsDisplay" class="selected-genres"></div>
                        </div>
                    </div>
                </div>

                <div id="watchlistItems" class="watchlist-items">
                    <div class="loading">Loading your watchlist...</div>
                </div>
            </div>

            <!-- Help Me Decide Wizard -->
            <div id="wizardOverlay" class="wizard-overlay" onclick="closeWizardOnOverlayClick(event)">
                <div class="wizard-modal" onclick="event.stopPropagation()">
                    <div class="wizard-header">
                        <h2>Help Me Decide</h2>
                        <button class="wizard-close" onclick="closeHelpMeDecideWizard()">Ã—</button>
                    </div>

                    <!-- Step 1: Select Media Type -->
                    <div id="wizardStep1" class="wizard-step active">
                        <h3>What type of media do you want to watch?</h3>
                        <div class="wizard-options" id="wizardMediaTypes"></div>
                        <div class="wizard-buttons">
                            <button class="btn" onclick="wizardNextStep()">Next</button>
                        </div>
                    </div>

                    <!-- Step 2: Select Genres -->
                    <div id="wizardStep2" class="wizard-step">
                        <h3>What genres are you in the mood for?</h3>
                        <div class="wizard-options" id="wizardGenres"></div>
                        <div class="wizard-buttons">
                            <button class="btn btn-secondary" onclick="wizardPrevStep()">Back</button>
                            <button class="btn" onclick="wizardShowResults()">Show Me!</button>
                        </div>
                    </div>

                    <!-- Step 3: Results -->
                    <div id="wizardStep3" class="wizard-step">
                        <h3>Here are 3 suggestions for you:</h3>
                        <div id="wizardResults" class="wizard-results"></div>
                        <div class="wizard-buttons">
                            <button class="btn btn-secondary" onclick="wizardPrevStep()">Back</button>
                            <button class="btn" onclick="wizardShowResults()">Show Different Items</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>

    <script>
        // ========== CONFIGURATION ==========
        const CONFIG = {
            PASSWORD: 'give me movie show',
            TMDB_API_KEY: 'e3cabd714830aea7a4e8ff5d7d0b7044',
            RAWG_API_KEY: '44ba0f7cd39d4d5a89e9e69cdbf967a2',

            // Firebase Configuration
            FIREBASE: {
                apiKey: "AIzaSyDvFCUnadbVzci6GrkXc4coybXEL-UDSww",
                authDomain: "watchlist-app-ec3a0.firebaseapp.com",
                projectId: "watchlist-app-ec3a0",
                storageBucket: "watchlist-app-ec3a0.firebasestorage.app",
                messagingSenderId: "585504841013",
                appId: "1:585504841013:web:f04fefc27095c3054e407c",
                measurementId: "G-4GKX86XXPJ"
            }
        };

        // Initialize Firebase
        firebase.initializeApp(CONFIG.FIREBASE);
        const db = firebase.firestore();
        const watchlistCollection = db.collection('watchlist');

        let watchlist = [];
        let currentFilter = 'all';
        let selectedGenres = [];
        let selectedTags = [];
        let genreMap = { movie: {}, tv: {} };
        let collapsedItems = new Set();

        // ========== GENRE MANAGEMENT ==========
        async function loadGenres() {
            try {
                // Fetch movie genres
                const movieResponse = await fetch(
                    `https://api.themoviedb.org/3/genre/movie/list?api_key=${CONFIG.TMDB_API_KEY}`
                );
                const movieData = await movieResponse.json();
                movieData.genres.forEach(g => {
                    genreMap.movie[g.id] = g.name;
                });

                // Fetch TV genres
                const tvResponse = await fetch(
                    `https://api.themoviedb.org/3/genre/tv/list?api_key=${CONFIG.TMDB_API_KEY}`
                );
                const tvData = await tvResponse.json();
                tvData.genres.forEach(g => {
                    genreMap.tv[g.id] = g.name;
                });
            } catch (error) {
                console.error('Error loading genres:', error);
            }
        }

        async function migrateExistingItems() {
            console.log('Starting genre migration...');
            let updateCount = 0;
            let errorCount = 0;

            for (const item of watchlist) {
                // Skip if item already has genres or is not a movie/TV show
                if ((item.genres && item.genres.length > 0) || (item.type !== 'movie' && item.type !== 'tv')) {
                    continue;
                }

                // Skip if no API ID
                if (!item.apiId) {
                    continue;
                }

                try {
                    // Fetch details from TMDB
                    const response = await fetch(
                        `https://api.themoviedb.org/3/${item.type}/${item.apiId}?api_key=${CONFIG.TMDB_API_KEY}`
                    );
                    const details = await response.json();

                    if (details.genres && details.genres.length > 0) {
                        item.genres = details.genres.map(g => g.name);
                        await saveItem(item);
                        updateCount++;
                        console.log(`Updated genres for: ${item.title}`);
                    }

                    // Small delay to avoid rate limiting
                    await new Promise(resolve => setTimeout(resolve, 250));
                } catch (error) {
                    console.error(`Error updating genres for ${item.title}:`, error);
                    errorCount++;
                }
            }

            console.log(`Migration complete! Updated ${updateCount} items. Errors: ${errorCount}`);
            alert(`Genre migration complete!\nUpdated: ${updateCount} items\nErrors: ${errorCount}`);
        }

        async function autoMigrateIfNeeded() {
            // Check if migration has already been run
            const migrated = localStorage.getItem('genreMigrationComplete');
            if (migrated === 'true') {
                return;
            }

            // Check if any movies/TV shows are missing genres
            const needsMigration = watchlist.some(item =>
                (item.type === 'movie' || item.type === 'tv') &&
                item.apiId &&
                (!item.genres || item.genres.length === 0)
            );

            if (needsMigration) {
                const shouldMigrate = confirm(
                    'Would you like to automatically add genre information to your existing movies and TV shows?\n\n' +
                    'This will fetch genre data from TMDB for all items. It may take a minute.'
                );

                if (shouldMigrate) {
                    await migrateExistingItems();
                    localStorage.setItem('genreMigrationComplete', 'true');
                }
            } else {
                localStorage.setItem('genreMigrationComplete', 'true');
            }
        }

        // ========== LOGIN ==========
        function login() {
            const password = document.getElementById('passwordInput').value;
            if (password === CONFIG.PASSWORD) {
                localStorage.setItem('authenticated', 'true');
                showApp();
            } else {
                document.getElementById('loginError').textContent = 'Incorrect password';
            }
        }

        function logout() {
            localStorage.removeItem('authenticated');
            location.reload();
        }

        async function showApp() {
            document.getElementById('loginPage').style.display = 'none';
            document.getElementById('appPage').classList.add('active');
            await loadGenres();
            loadWatchlist();
        }

        // Check if already logged in
        if (localStorage.getItem('authenticated') === 'true') {
            showApp();
        }

        // Enter key to login
        document.addEventListener('DOMContentLoaded', () => {
            const passwordInput = document.getElementById('passwordInput');
            if (passwordInput) {
                passwordInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') login();
                });
            }

            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') searchMedia();
                });
            }
        });

        // ========== FIRESTORE DATABASE ==========
        let isFirstLoad = true;
        let seenItems = new Set();

        async function loadWatchlist() {
            try {
                // Set up real-time listener for automatic syncing
                watchlistCollection.orderBy('addedDate', 'desc').onSnapshot(async (snapshot) => {
                    watchlist = [];
                    snapshot.forEach((doc) => {
                        const item = { firestoreId: doc.id, ...doc.data() };
                        watchlist.push(item);
                        // Collapse new items by default (items we haven't seen before)
                        if (!seenItems.has(item.firestoreId)) {
                            collapsedItems.add(item.firestoreId);
                            seenItems.add(item.firestoreId);
                        }
                    });
                    renderWatchlist();

                    // Run migration check only on first load
                    if (isFirstLoad) {
                        isFirstLoad = false;
                        await autoMigrateIfNeeded();
                    }
                }, (error) => {
                    console.error('Error loading watchlist:', error);
                    alert('Failed to load watchlist. Please check your Firebase configuration.');
                });
            } catch (error) {
                console.error('Error setting up watchlist listener:', error);
                watchlist = [];
                renderWatchlist();
            }
        }

        async function saveItem(item) {
            try {
                if (item.firestoreId) {
                    // Update existing item
                    await watchlistCollection.doc(item.firestoreId).update(item);
                } else {
                    // Add new item
                    await watchlistCollection.add(item);
                }
                return true;
            } catch (error) {
                console.error('Error saving item:', error);
                alert('Failed to save changes. Please check your Firebase configuration.');
                return false;
            }
        }

        async function deleteItemFromDb(firestoreId) {
            try {
                await watchlistCollection.doc(firestoreId).delete();
                return true;
            } catch (error) {
                console.error('Error deleting item:', error);
                alert('Failed to delete item.');
                return false;
            }
        }

        // ========== MEDIA SEARCH APIs ==========
        async function searchMedia() {
            const query = document.getElementById('searchInput').value.trim();
            const mediaType = currentSearchMediaType;

            if (!query) return;

            const resultsContainer = document.getElementById('searchResults');
            resultsContainer.innerHTML = '<div class="loading">Searching...</div>';

            try {
                let results = [];

                switch(mediaType) {
                    case 'movie':
                    case 'tv':
                        results = await searchTMDB(query, mediaType);
                        break;
                    case 'game':
                        results = await searchGames(query);
                        break;
                    case 'book':
                        results = await searchBooks(query);
                        break;
                    case 'podcast':
                        results = await searchPodcasts(query);
                        break;
                }

                if (results && results.length > 0) {
                    resultsContainer.innerHTML = results.map(item => `
                        <div class="search-result-item" onclick='addToWatchlist(${JSON.stringify(item).replace(/'/g, "&apos;")})'>
                            ${item.image
                                ? `<img src="${item.image}" alt="${item.title}">`
                                : '<div style="width:100%;height:225px;background:#e0e0e0;display:flex;align-items:center;justify-content:center;color:#999;font-size:12px;">No Image</div>'
                            }
                            <div class="title">${item.title}</div>
                        </div>
                    `).join('');
                } else {
                    resultsContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #718096;">No results found</div>';
                }
            } catch (error) {
                console.error('Error searching:', error);
                resultsContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #e74c3c;">Search failed. Check your API keys.</div>';
            }
        }

        async function searchTMDB(query, mediaType) {
            const response = await fetch(
                `https://api.themoviedb.org/3/search/${mediaType}?api_key=${CONFIG.TMDB_API_KEY}&query=${encodeURIComponent(query)}`
            );
            const data = await response.json();

            return (data.results || []).slice(0, 12).map(item => {
                // Convert genre IDs to genre names
                const genres = (item.genre_ids || []).map(id => genreMap[mediaType][id]).filter(Boolean);

                return {
                    type: mediaType,
                    apiId: item.id,
                    title: item.title || item.name,
                    year: (item.release_date || item.first_air_date || '').substring(0, 4),
                    image: item.poster_path ? `https://image.tmdb.org/t/p/w200${item.poster_path}` : null,
                    overview: item.overview,
                    genres: genres,
                    rawData: item
                };
            });
        }

        async function searchGames(query) {
            const response = await fetch(
                `https://api.rawg.io/api/games?key=${CONFIG.RAWG_API_KEY}&search=${encodeURIComponent(query)}&page_size=12`
            );
            const data = await response.json();

            return (data.results || []).map(item => ({
                type: 'game',
                apiId: item.id,
                title: item.name,
                year: item.released ? item.released.substring(0, 4) : null,
                image: item.background_image,
                overview: `Platforms: ${(item.platforms || []).map(p => p.platform.name).slice(0, 3).join(', ')}`,
                rating: item.rating,
                url: `https://rawg.io/games/${item.slug}`,
                rawData: item
            }));
        }

        async function searchBooks(query) {
            const response = await fetch(
                `https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(query)}&maxResults=12`
            );
            const data = await response.json();

            return (data.items || []).map(item => {
                const volumeInfo = item.volumeInfo;
                return {
                    type: 'book',
                    apiId: item.id,
                    title: volumeInfo.title,
                    year: volumeInfo.publishedDate ? volumeInfo.publishedDate.substring(0, 4) : null,
                    image: volumeInfo.imageLinks?.thumbnail,
                    overview: volumeInfo.description || `By ${(volumeInfo.authors || []).join(', ')}`,
                    author: (volumeInfo.authors || []).join(', '),
                    url: volumeInfo.infoLink,
                    rawData: item
                };
            });
        }

        async function searchPodcasts(query) {
            const response = await fetch(
                `https://itunes.apple.com/search?term=${encodeURIComponent(query)}&media=podcast&limit=12`
            );
            const data = await response.json();

            return (data.results || []).map(item => ({
                type: 'podcast',
                apiId: item.collectionId,
                title: item.collectionName,
                year: null,
                image: item.artworkUrl600 || item.artworkUrl100,
                overview: `By ${item.artistName}`,
                artist: item.artistName,
                url: item.collectionViewUrl,
                rawData: item
            }));
        }

        async function addToWatchlist(item) {
            try {
                let newItem = {
                    apiId: item.apiId,
                    title: item.title,
                    type: item.type,
                    year: item.year,
                    poster: item.image,
                    overview: item.overview,
                    genres: item.genres || [],
                    tags: [],
                    watched: false,
                    review: null,
                    samRating: null,
                    leslieRating: null,
                    addedDate: new Date().toISOString()
                };

                // Add type-specific metadata
                if (item.type === 'movie' || item.type === 'tv') {
                    // Get TMDB details for watch providers
                    try {
                        const detailsResponse = await fetch(
                            `https://api.themoviedb.org/3/${item.type}/${item.apiId}?api_key=${CONFIG.TMDB_API_KEY}&append_to_response=watch/providers`
                        );
                        const details = await detailsResponse.json();
                        newItem.poster = item.rawData.poster_path ? `https://image.tmdb.org/t/p/w500${item.rawData.poster_path}` : null;
                        newItem.tmdbUrl = `https://www.themoviedb.org/${item.type}/${item.apiId}`;
                        newItem.whereToWatch = details['watch/providers']?.results?.US?.link || null;
                    } catch (e) {
                        console.error('Error fetching TMDB details:', e);
                    }
                } else if (item.type === 'game') {
                    newItem.url = item.url;
                    newItem.rating = item.rating;
                } else if (item.type === 'book') {
                    newItem.url = item.url;
                    newItem.author = item.author;
                } else if (item.type === 'podcast') {
                    newItem.url = item.url;
                    newItem.artist = item.artist;
                }

                await saveItem(newItem);
                document.getElementById('searchResults').innerHTML = '';
                document.getElementById('searchInput').value = '';
            } catch (error) {
                console.error('Error adding item:', error);
                alert('Failed to add item');
            }
        }

        async function addManualItem() {
            const title = document.getElementById('manualTitle').value.trim();
            const type = document.getElementById('manualType').value.trim();
            const notes = document.getElementById('manualNotes').value.trim();

            if (!title) {
                alert('Please enter a title');
                return;
            }

            const newItem = {
                title: title,
                type: type || 'other',
                overview: notes,
                tags: [],
                watched: false,
                review: null,
                samRating: null,
                leslieRating: null,
                addedDate: new Date().toISOString(),
                manual: true
            };

            await saveItem(newItem);

            // Clear form
            document.getElementById('manualTitle').value = '';
            document.getElementById('manualType').value = '';
            document.getElementById('manualNotes').value = '';
        }

        // ========== WATCHLIST MANAGEMENT ==========
        async function toggleWatched(firestoreId) {
            const item = watchlist.find(i => i.firestoreId === firestoreId);
            if (item) {
                item.watched = !item.watched;
                item.watchedDate = item.watched ? new Date().toISOString() : null;
                await saveItem(item);
            }
        }

        async function saveReview(firestoreId) {
            const item = watchlist.find(i => i.firestoreId === firestoreId);
            const review = document.getElementById(`review-${firestoreId}`).value.trim();

            if (item && review) {
                item.review = review;
                await saveItem(item);
            }
        }

        async function saveNotes(firestoreId) {
            const item = watchlist.find(i => i.firestoreId === firestoreId);
            const notes = document.getElementById(`notes-${firestoreId}`).value.trim();

            if (item) {
                item.notes = notes || null;
                await saveItem(item);
                renderWatchlist();
            }
        }

        async function addTag(firestoreId) {
            const item = watchlist.find(i => i.firestoreId === firestoreId);
            const tagInput = document.getElementById(`tag-input-${firestoreId}`);
            const newTag = tagInput.value.trim();

            if (item && newTag) {
                if (!item.tags) {
                    item.tags = [];
                }
                if (!item.tags.includes(newTag)) {
                    item.tags.push(newTag);
                    await saveItem(item);
                    tagInput.value = '';
                    renderWatchlist();
                }
            }
        }

        async function removeTag(firestoreId, tag) {
            const item = watchlist.find(i => i.firestoreId === firestoreId);
            if (item && item.tags) {
                item.tags = item.tags.filter(t => t !== tag);
                await saveItem(item);
                renderWatchlist();
            }
        }

        async function saveRatings(firestoreId) {
            const item = watchlist.find(i => i.firestoreId === firestoreId);
            if (!item) return;

            const samRatingInput = document.getElementById(`sam-rating-${firestoreId}`).value.trim();
            const leslieRatingInput = document.getElementById(`leslie-rating-${firestoreId}`).value.trim();

            const samRating = parseFloat(samRatingInput);
            const leslieRating = parseFloat(leslieRatingInput);

            // Validate ratings: must be 0-10 in 0.5 increments
            item.samRating = (!isNaN(samRating) && samRating >= 0 && samRating <= 10 && (samRating * 2) % 1 === 0) ? samRating : null;
            item.leslieRating = (!isNaN(leslieRating) && leslieRating >= 0 && leslieRating <= 10 && (leslieRating * 2) % 1 === 0) ? leslieRating : null;

            await saveItem(item);
            renderWatchlist();
        }

        function renderStars(rating) {
            if (rating === null || rating === undefined || rating === '') {
                return '<span class="rating-number">Not rated yet</span>';
            }

            const fullCircles = Math.floor(rating);
            const hasHalfCircle = (rating % 1) !== 0;
            const emptyCircles = 10 - fullCircles - (hasHalfCircle ? 1 : 0);

            let starsHtml = 'â—'.repeat(fullCircles);
            if (hasHalfCircle) {
                starsHtml += 'â—';
            }
            starsHtml += 'â—‹'.repeat(emptyCircles);

            return `<span class="stars-display">${starsHtml}</span><span class="rating-number">(${rating}/10)</span>`;
        }

        function renderRatingInput(firestoreId, person, personLabel, currentRating) {
            const displayValue = currentRating !== null && currentRating !== undefined ? currentRating : '';
            return `
                <div class="rating-input-group">
                    <div class="rating-label">${personLabel}'s Rating:</div>
                    <div class="rating-row">
                        <input
                            type="number"
                            id="${person}-rating-${firestoreId}"
                            value="${displayValue}"
                            min="0"
                            max="10"
                            step="0.5"
                            inputmode="decimal"
                            placeholder="0-10"
                            onkeypress="if(event.key === 'Enter') saveRatings('${firestoreId}')"
                        >
                        ${renderStars(currentRating)}
                    </div>
                </div>
            `;
        }

        async function deleteItem(firestoreId) {
            const item = watchlist.find(i => i.firestoreId === firestoreId);
            if (item && confirm(`Remove "${item.title}" from watchlist?`)) {
                await deleteItemFromDb(firestoreId);
            }
        }

        // ========== FILTER FUNCTIONS ==========
        const mediaTypeOptions = [
            { value: 'all', label: 'All' },
            { value: 'movie', label: 'Movies' },
            { value: 'tv', label: 'TV Shows' },
            { value: 'game', label: 'Games' },
            { value: 'book', label: 'Books' },
            { value: 'podcast', label: 'Podcasts' },
            { value: 'other', label: 'Other' }
        ];

        const searchMediaTypeOptions = [
            { value: 'movie', label: 'Movie' },
            { value: 'tv', label: 'TV Show' },
            { value: 'game', label: 'Game' },
            { value: 'book', label: 'Book' },
            { value: 'podcast', label: 'Podcast' },
            { value: 'manual', label: 'Other (Manual)' }
        ];

        const specialFilters = ['Watched', 'Unwatched'];

        let currentSearchMediaType = 'movie';

        function updateMediaTypeDropdown() {
            const dropdown = document.getElementById('mediaTypeDropdown');

            dropdown.innerHTML = mediaTypeOptions.map(option => `
                <div class="genre-option" onclick="selectMediaType('${option.value}')">
                    ${option.value === currentFilter ? 'âœ“ ' : ''}${option.label}
                </div>
            `).join('');
        }

        function toggleMediaTypeDropdown(event) {
            if (event) event.stopPropagation();
            const dropdown = document.getElementById('mediaTypeDropdown');
            dropdown.classList.toggle('active');
            updateMediaTypeDropdown();
        }

        function selectMediaType(value) {
            currentFilter = value;
            const button = document.getElementById('mediaTypeFilterButton');
            const option = mediaTypeOptions.find(opt => opt.value === value);
            button.textContent = option ? option.label : 'All';

            const dropdown = document.getElementById('mediaTypeDropdown');
            dropdown.classList.remove('active');

            renderWatchlist();
        }

        function updateSearchMediaTypeDropdown() {
            const dropdown = document.getElementById('searchMediaTypeDropdown');

            dropdown.innerHTML = searchMediaTypeOptions.map(option => `
                <div class="genre-option" onclick="selectSearchMediaType('${option.value}')">
                    ${option.value === currentSearchMediaType ? 'âœ“ ' : ''}${option.label}
                </div>
            `).join('');
        }

        function toggleSearchMediaTypeDropdown(event) {
            if (event) event.stopPropagation();
            const dropdown = document.getElementById('searchMediaTypeDropdown');
            dropdown.classList.toggle('active');
            updateSearchMediaTypeDropdown();
        }

        function selectSearchMediaType(value) {
            currentSearchMediaType = value;
            const button = document.getElementById('searchMediaTypeButton');
            const option = searchMediaTypeOptions.find(opt => opt.value === value);
            button.textContent = option ? option.label : 'Movie';

            const dropdown = document.getElementById('searchMediaTypeDropdown');
            dropdown.classList.remove('active');

            // Handle manual mode
            const manualForm = document.getElementById('manualAddForm');
            const searchBox = document.getElementById('searchInput').parentElement;
            if (value === 'manual') {
                manualForm.style.display = 'block';
                searchBox.style.display = 'none';
                document.getElementById('searchResults').innerHTML = '';
            } else {
                manualForm.style.display = 'none';
                searchBox.style.display = 'flex';
            }
        }

        function getAllGenres() {
            const genresSet = new Set();
            watchlist.forEach(item => {
                if (item.genres && Array.isArray(item.genres)) {
                    item.genres.forEach(genre => genresSet.add(genre));
                }
            });
            return Array.from(genresSet).sort();
        }

        function updateGenreDropdown() {
            const allGenres = getAllGenres();
            const dropdown = document.getElementById('genreDropdown');

            let options = [];

            // Add special filters first
            options.push(...specialFilters.map(filter => `
                <div class="genre-option" onclick="toggleGenre('${filter}'); event.stopPropagation();">
                    <input type="checkbox" id="genre-${filter.replace(/[^a-zA-Z0-9]/g, '-')}"
                           ${selectedGenres.includes(filter) ? 'checked' : ''}>
                    <label>${filter}</label>
                </div>
            `));

            // Add separator if there are genres
            if (allGenres.length > 0) {
                options.push('<div style="border-top: 2px solid #e0e0e0; margin: 5px 0;"></div>');
            }

            // Add genre filters
            options.push(...allGenres.map(genre => `
                <div class="genre-option" onclick="toggleGenre('${genre.replace(/'/g, "\\'")}'); event.stopPropagation();">
                    <input type="checkbox" id="genre-${genre.replace(/[^a-zA-Z0-9]/g, '-')}"
                           ${selectedGenres.includes(genre) ? 'checked' : ''}>
                    <label>${genre}</label>
                </div>
            `));

            dropdown.innerHTML = options.join('');
        }

        function toggleGenreDropdown(event) {
            if (event) event.stopPropagation();
            const dropdown = document.getElementById('genreDropdown');
            dropdown.classList.toggle('active');
            updateGenreDropdown();
        }

        function toggleGenre(genre) {
            const index = selectedGenres.indexOf(genre);
            if (index > -1) {
                selectedGenres.splice(index, 1);
            } else {
                selectedGenres.push(genre);
            }
            updateSelectedGenresDisplay();
            updateGenreDropdown();
            renderWatchlist();
        }

        function removeGenre(genre) {
            const index = selectedGenres.indexOf(genre);
            if (index > -1) {
                selectedGenres.splice(index, 1);
            }
            updateSelectedGenresDisplay();
            updateGenreDropdown();
            renderWatchlist();
        }

        function getAllTags() {
            const tagsSet = new Set();
            watchlist.forEach(item => {
                if (item.tags && Array.isArray(item.tags)) {
                    item.tags.forEach(tag => tagsSet.add(tag));
                }
            });
            return Array.from(tagsSet).sort();
        }

        function updateTagDropdown() {
            const allTags = getAllTags();
            const dropdown = document.getElementById('tagDropdown');

            if (allTags.length === 0) {
                dropdown.innerHTML = '<div class="genre-option" style="padding: 15px; text-align: center; color: var(--color-text-secondary);">No tags yet</div>';
                return;
            }

            const options = allTags.map(tag => `
                <div class="genre-option" onclick="toggleTagFilter('${tag.replace(/'/g, "\\'")}'); event.stopPropagation();">
                    <input type="checkbox" id="tag-${tag.replace(/[^a-zA-Z0-9]/g, '-')}"
                           ${selectedTags.includes(tag) ? 'checked' : ''}>
                    <label>${tag}</label>
                </div>
            `);

            dropdown.innerHTML = options.join('');
        }

        function toggleTagDropdown(event) {
            if (event) event.stopPropagation();
            const dropdown = document.getElementById('tagDropdown');
            dropdown.classList.toggle('active');
            updateTagDropdown();
        }

        function toggleTagFilter(tag) {
            const index = selectedTags.indexOf(tag);
            if (index > -1) {
                selectedTags.splice(index, 1);
            } else {
                selectedTags.push(tag);
            }
            updateSelectedTagsDisplay();
            updateTagDropdown();
            renderWatchlist();
        }

        function removeTagFilter(tag) {
            const index = selectedTags.indexOf(tag);
            if (index > -1) {
                selectedTags.splice(index, 1);
            }
            updateSelectedTagsDisplay();
            updateTagDropdown();
            renderWatchlist();
        }

        function updateSelectedTagsDisplay() {
            const display = document.getElementById('selectedTagsDisplay');
            if (selectedTags.length === 0) {
                display.innerHTML = '';
                return;
            }

            display.innerHTML = selectedTags.map(tag => `
                <div class="genre-tag">
                    ${tag}
                    <span class="genre-tag-remove" onclick="removeTagFilter('${tag.replace(/'/g, "\\'")}')">Ã—</span>
                </div>
            `).join('');
        }

        function toggleCollapse(firestoreId) {
            if (collapsedItems.has(firestoreId)) {
                collapsedItems.delete(firestoreId);
            } else {
                collapsedItems.add(firestoreId);
            }
            renderWatchlist();
        }

        function toggleAllCollapsed() {
            const visibleItems = getFilteredWatchlist();
            const allCollapsed = visibleItems.every(item => collapsedItems.has(item.firestoreId));

            if (allCollapsed) {
                // Expand all
                visibleItems.forEach(item => collapsedItems.delete(item.firestoreId));
                document.getElementById('collapseAllText').textContent = 'Collapse All';
            } else {
                // Collapse all
                visibleItems.forEach(item => collapsedItems.add(item.firestoreId));
                document.getElementById('collapseAllText').textContent = 'Expand All';
            }
            renderWatchlist();
        }

        function getFilteredWatchlist() {
            let filtered = watchlist;

            // Apply media type filter
            if (currentFilter === 'movie') {
                filtered = filtered.filter(item => item.type === 'movie');
            } else if (currentFilter === 'tv') {
                filtered = filtered.filter(item => item.type === 'tv');
            } else if (currentFilter === 'game') {
                filtered = filtered.filter(item => item.type === 'game');
            } else if (currentFilter === 'book') {
                filtered = filtered.filter(item => item.type === 'book');
            } else if (currentFilter === 'podcast') {
                filtered = filtered.filter(item => item.type === 'podcast');
            } else if (currentFilter === 'other') {
                filtered = filtered.filter(item => !['movie', 'tv', 'game', 'book', 'podcast'].includes(item.type));
            }

            // Apply genre and special filters (show items matching ANY selected filter)
            if (selectedGenres.length > 0) {
                filtered = filtered.filter(item => {
                    // Check special filters first
                    if (selectedGenres.includes('Watched') && item.watched) return true;
                    if (selectedGenres.includes('Unwatched') && !item.watched) return true;

                    // Then check genre filters
                    if (item.genres && Array.isArray(item.genres)) {
                        const regularGenres = selectedGenres.filter(g => !specialFilters.includes(g));
                        if (regularGenres.length > 0) {
                            return item.genres.some(genre => regularGenres.includes(genre));
                        }
                    }

                    return false;
                });
            }

            // Apply tag filters (show items matching ANY selected tag)
            if (selectedTags.length > 0) {
                filtered = filtered.filter(item => {
                    if (item.tags && Array.isArray(item.tags)) {
                        return item.tags.some(tag => selectedTags.includes(tag));
                    }
                    return false;
                });
            }

            return filtered;
        }

        function updateSelectedGenresDisplay() {
            const display = document.getElementById('selectedGenresDisplay');
            if (selectedGenres.length === 0) {
                display.innerHTML = '';
                return;
            }

            display.innerHTML = selectedGenres.map(genre => `
                <div class="genre-tag">
                    ${genre}
                    <span class="genre-tag-remove" onclick="removeGenre('${genre.replace(/'/g, "\\'")}')">Ã—</span>
                </div>
            `).join('');
        }

        // Close dropdowns when clicking outside
        document.addEventListener('click', (e) => {
            const genreDropdown = document.getElementById('genreDropdown');
            const genreButton = document.getElementById('genreFilterButton');
            if (genreDropdown && genreButton && !genreDropdown.contains(e.target) && !genreButton.contains(e.target)) {
                genreDropdown.classList.remove('active');
            }

            const mediaTypeDropdown = document.getElementById('mediaTypeDropdown');
            const mediaTypeButton = document.getElementById('mediaTypeFilterButton');
            if (mediaTypeDropdown && mediaTypeButton && !mediaTypeDropdown.contains(e.target) && !mediaTypeButton.contains(e.target)) {
                mediaTypeDropdown.classList.remove('active');
            }

            const searchMediaTypeDropdown = document.getElementById('searchMediaTypeDropdown');
            const searchMediaTypeButton = document.getElementById('searchMediaTypeButton');
            if (searchMediaTypeDropdown && searchMediaTypeButton && !searchMediaTypeDropdown.contains(e.target) && !searchMediaTypeButton.contains(e.target)) {
                searchMediaTypeDropdown.classList.remove('active');
            }

            const tagDropdown = document.getElementById('tagDropdown');
            const tagButton = document.getElementById('tagFilterButton');
            if (tagDropdown && tagButton && !tagDropdown.contains(e.target) && !tagButton.contains(e.target)) {
                tagDropdown.classList.remove('active');
            }
        });

        function renderWatchlist() {
            const container = document.getElementById('watchlistItems');

            const filtered = getFilteredWatchlist();

            // Update collapse all button text based on current state
            const visibleItems = filtered.filter(item => item.firestoreId);
            const allCollapsed = visibleItems.length > 0 && visibleItems.every(item => collapsedItems.has(item.firestoreId));
            const collapseAllText = document.getElementById('collapseAllText');
            if (collapseAllText) {
                collapseAllText.textContent = allCollapsed ? 'Expand All' : 'Collapse All';
            }

            if (filtered.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <h3>Nothing here yet!</h3>
                        <p>Start adding movies, shows, or other media to your watchlist.</p>
                    </div>
                `;
                return;
            }

            container.innerHTML = filtered.map(item => {
                const isCollapsed = collapsedItems.has(item.firestoreId);
                return `
                <div class="watchlist-item ${item.watched ? 'watched' : ''} ${isCollapsed ? 'collapsed' : ''}">
                    ${item.poster
                        ? `<img src="${item.poster}" alt="${item.title}" class="item-poster" onclick="toggleCollapse('${item.firestoreId}')" style="cursor: pointer;">`
                        : '<div class="item-poster" style="background: #e0e0e0; display: flex; align-items: center; justify-content: center; color: #999; cursor: pointer;" onclick="toggleCollapse(\'' + item.firestoreId + '\')">No Image</div>'
                    }

                    <div class="item-details">
                        <div class="item-title" onclick="toggleCollapse('${item.firestoreId}')" style="cursor: pointer;">${item.title}</div>
                        <div class="item-meta">
                            ${item.type.toUpperCase()}
                            ${item.year ? ` â€¢ ${item.year}` : ''}
                            ${item.author ? ` â€¢ ${item.author}` : ''}
                            ${item.artist ? ` â€¢ ${item.artist}` : ''}
                            ${item.rating ? ` â€¢ â­ ${item.rating}` : ''}
                            ${item.watched ? ' â€¢ âœ“ Watched' : ''}
                        </div>
                        ${item.genres && item.genres.length > 0 ? `
                            <div class="item-genres">
                                ${item.genres.map(genre => `<span class="genre-badge">${genre}</span>`).join('')}
                            </div>
                        ` : ''}
                        ${item.notes ? `
                            <div class="item-notes">
                                <strong>Note:</strong> ${item.notes}
                            </div>
                        ` : ''}

                        <!-- Notes Edit Section -->
                        <div class="notes-section">
                            <div><strong>${item.notes ? 'Edit note:' : 'Add a note:'}</strong></div>
                            <div class="notes-form">
                                <textarea id="notes-${item.firestoreId}" placeholder="Who recommended this? Why do you want to watch it?">${item.notes || ''}</textarea>
                                <button class="btn btn-small" style="margin-top: 8px;" onclick="saveNotes('${item.firestoreId}')">Save Note</button>
                            </div>
                        </div>

                        <!-- Tags Section -->
                        <div class="tags-section">
                            <div><strong>Tags:</strong></div>
                            ${item.tags && item.tags.length > 0 ? `
                                <div class="item-tags" style="margin-top: 8px;">
                                    ${item.tags.map(tag => `
                                        <span class="tag-badge">
                                            ${tag}
                                            <span class="tag-remove" onclick="removeTag('${item.firestoreId}', '${tag.replace(/'/g, "\\'")}')">Ã—</span>
                                        </span>
                                    `).join('')}
                                </div>
                            ` : '<div style="color: var(--color-text-secondary); font-size: 0.9em; margin-top: 5px;">No tags yet</div>'}
                            <div class="tag-form" style="margin-top: 10px; display: flex; gap: 8px;">
                                <input type="text" id="tag-input-${item.firestoreId}" placeholder="Add a tag..." style="flex: 1; padding: 8px; border: 2px solid var(--color-border); border-radius: 8px; font-size: 14px;" onkeypress="if(event.key === 'Enter') addTag('${item.firestoreId}')">
                                <button class="btn btn-small" onclick="addTag('${item.firestoreId}')">Add Tag</button>
                            </div>
                        </div>

                        ${item.overview ? `<div class="item-overview">${item.overview}</div>` : ''}

                        ${(item.tmdbUrl || item.whereToWatch || item.url) ? `
                            <div class="item-links">
                                ${item.tmdbUrl ? `<a href="${item.tmdbUrl}" target="_blank">View on TMDB</a>` : ''}
                                ${item.whereToWatch ? `<a href="${item.whereToWatch}" target="_blank">Where to Watch</a>` : ''}
                                ${item.url && !item.tmdbUrl ? `<a href="${item.url}" target="_blank">View Details</a>` : ''}
                            </div>
                        ` : ''}

                        ${item.watched ? `
                            <!-- Ratings Section -->
                            <div class="ratings-section">
                                ${renderRatingInput(item.firestoreId, 'sam', 'Sam', item.samRating)}
                                ${renderRatingInput(item.firestoreId, 'leslie', 'Leslie', item.leslieRating)}
                                <button class="btn btn-small" onclick="saveRatings('${item.firestoreId}')">Save Ratings</button>
                            </div>
                        ` : ''}

                        ${item.watched ? `
                            <div class="review-section">
                                ${item.review
                                    ? `<div><strong>Review:</strong><div class="review-text">${item.review}</div></div>`
                                    : `
                                        <div><strong>Add a review:</strong></div>
                                        <div class="review-form">
                                            <textarea id="review-${item.firestoreId}" placeholder="What did you think?"></textarea>
                                            <button class="btn btn-small" style="margin-top: 8px;" onclick="saveReview('${item.firestoreId}')">Save Review</button>
                                        </div>
                                    `
                                }
                            </div>
                        ` : ''}
                    </div>

                    <div class="item-actions">
                        <button class="btn-action btn-watched" onclick="toggleWatched('${item.firestoreId}')">
                            ${item.watched ? 'Mark Unwatched' : 'Mark Watched'}
                        </button>
                        <button class="btn-action btn-delete" onclick="deleteItem('${item.firestoreId}')">Remove</button>
                    </div>
                </div>
            `;
            }).join('');
        }

        // ========== HELP ME DECIDE WIZARD ==========
        let wizardState = {
            currentStep: 1,
            selectedMediaTypes: [],
            selectedWizardGenres: []
        };

        function openHelpMeDecideWizard() {
            // Reset wizard state
            wizardState = {
                currentStep: 1,
                selectedMediaTypes: [],
                selectedWizardGenres: []
            };

            // Populate media types
            const mediaTypesContainer = document.getElementById('wizardMediaTypes');
            const availableTypes = [...new Set(watchlist.map(item => item.type))].sort();

            mediaTypesContainer.innerHTML = availableTypes.map(type => {
                const label = mediaTypeOptions.find(opt => opt.value === type)?.label || type;
                return `
                    <div class="wizard-option" onclick="toggleWizardMediaType('${type}')">
                        <input type="checkbox" id="wizard-type-${type}" onchange="toggleWizardMediaType('${type}')">
                        <label for="wizard-type-${type}">${label}</label>
                    </div>
                `;
            }).join('');

            // Show wizard
            document.getElementById('wizardOverlay').classList.add('active');
            showWizardStep(1);
        }

        function closeHelpMeDecideWizard() {
            document.getElementById('wizardOverlay').classList.remove('active');
        }

        function closeWizardOnOverlayClick(event) {
            if (event.target.id === 'wizardOverlay') {
                closeHelpMeDecideWizard();
            }
        }

        function toggleWizardMediaType(type) {
            const index = wizardState.selectedMediaTypes.indexOf(type);
            const checkbox = document.getElementById(`wizard-type-${type}`);

            if (index > -1) {
                wizardState.selectedMediaTypes.splice(index, 1);
                checkbox.checked = false;
                checkbox.parentElement.classList.remove('selected');
            } else {
                wizardState.selectedMediaTypes.push(type);
                checkbox.checked = true;
                checkbox.parentElement.classList.add('selected');
            }
        }

        function toggleWizardGenre(genre) {
            const index = wizardState.selectedWizardGenres.indexOf(genre);
            const checkbox = document.getElementById(`wizard-genre-${genre.replace(/[^a-zA-Z0-9]/g, '-')}`);

            if (index > -1) {
                wizardState.selectedWizardGenres.splice(index, 1);
                checkbox.checked = false;
                checkbox.parentElement.classList.remove('selected');
            } else {
                wizardState.selectedWizardGenres.push(genre);
                checkbox.checked = true;
                checkbox.parentElement.classList.add('selected');
            }
        }

        function showWizardStep(step) {
            wizardState.currentStep = step;

            // Hide all steps
            document.querySelectorAll('.wizard-step').forEach(el => el.classList.remove('active'));

            // Show current step
            document.getElementById(`wizardStep${step}`).classList.add('active');
        }

        function wizardNextStep() {
            if (wizardState.currentStep === 1) {
                // Validate at least one media type is selected
                if (wizardState.selectedMediaTypes.length === 0) {
                    alert('Please select at least one media type');
                    return;
                }

                // Populate genres based on selected media types
                const genresContainer = document.getElementById('wizardGenres');
                const genresSet = new Set();

                // Get all unwatched items matching selected media types
                const filteredItems = watchlist.filter(item =>
                    !item.watched && wizardState.selectedMediaTypes.includes(item.type)
                );

                filteredItems.forEach(item => {
                    if (item.genres && Array.isArray(item.genres)) {
                        item.genres.forEach(genre => genresSet.add(genre));
                    }
                });

                const genres = Array.from(genresSet).sort();

                if (genres.length === 0) {
                    genresContainer.innerHTML = `
                        <div class="wizard-empty">
                            <p>No genres available for the selected media types. Click "Show Me!" to see random items.</p>
                        </div>
                    `;
                } else {
                    genresContainer.innerHTML = genres.map(genre => `
                        <div class="wizard-option" onclick="toggleWizardGenre('${genre.replace(/'/g, "\\'")}')">
                            <input type="checkbox" id="wizard-genre-${genre.replace(/[^a-zA-Z0-9]/g, '-')}" onchange="toggleWizardGenre('${genre.replace(/'/g, "\\'")}')">
                            <label for="wizard-genre-${genre.replace(/[^a-zA-Z0-9]/g, '-')}">${genre}</label>
                        </div>
                    `).join('');
                }

                showWizardStep(2);
            }
        }

        function wizardPrevStep() {
            if (wizardState.currentStep > 1) {
                showWizardStep(wizardState.currentStep - 1);
            }
        }

        function wizardShowResults() {
            // Filter watchlist based on selections
            let filteredItems = watchlist.filter(item =>
                !item.watched && wizardState.selectedMediaTypes.includes(item.type)
            );

            // Apply genre filter if any genres are selected
            if (wizardState.selectedWizardGenres.length > 0) {
                filteredItems = filteredItems.filter(item => {
                    if (item.genres && Array.isArray(item.genres)) {
                        return item.genres.some(genre => wizardState.selectedWizardGenres.includes(genre));
                    }
                    return false;
                });
            }

            const resultsContainer = document.getElementById('wizardResults');

            if (filteredItems.length === 0) {
                resultsContainer.innerHTML = `
                    <div class="wizard-empty">
                        <h3>No items found</h3>
                        <p>No unwatched items match your criteria. Try different selections!</p>
                    </div>
                `;
            } else {
                // Shuffle and get up to 3 random items
                const shuffled = filteredItems.sort(() => Math.random() - 0.5);
                const selectedItems = shuffled.slice(0, 3);

                resultsContainer.innerHTML = selectedItems.map(item => `
                    <div class="wizard-result-item">
                        ${item.poster
                            ? `<img src="${item.poster}" alt="${item.title}" class="wizard-result-poster">`
                            : '<div class="wizard-result-poster" style="background: #e0e0e0; display: flex; align-items: center; justify-content: center; color: #999; font-size: 12px;">No Image</div>'
                        }
                        <div class="wizard-result-details">
                            <div class="wizard-result-title">${item.title}</div>
                            <div class="wizard-result-meta">
                                ${item.type.toUpperCase()}
                                ${item.year ? ` â€¢ ${item.year}` : ''}
                                ${item.author ? ` â€¢ ${item.author}` : ''}
                                ${item.artist ? ` â€¢ ${item.artist}` : ''}
                            </div>
                            ${item.genres && item.genres.length > 0 ? `
                                <div class="item-genres">
                                    ${item.genres.map(genre => `<span class="genre-badge">${genre}</span>`).join('')}
                                </div>
                            ` : ''}
                            ${item.notes ? `
                                <div class="wizard-result-overview">
                                    <strong>Note:</strong> ${item.notes}
                                </div>
                            ` : ''}
                            ${item.overview && !item.notes ? `
                                <div class="wizard-result-overview">${item.overview}</div>
                            ` : ''}
                        </div>
                    </div>
                `).join('');
            }

            showWizardStep(3);
        }
    </script>
</body>
</html>
